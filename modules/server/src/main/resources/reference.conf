sharry {

  # the database connection. sharry is distributed with the H2
  # database.
  db {
    driver = "org.h2.Driver"
    url = "jdbc:h2:./sharry-db.h2"
    user = "sa"
    password = ""
  }

  log {
    # A logback configuration file to use instead of the default config
    config = ""
  }

  upload {
    # When storing and transfering binary data use chunks of this size.
    chunk-size = "256K"

    # Allow simultaneous uploads
    simultaneous-uploads = 3

    # Maximum number of files that can be uploaded to one share
    max-files = 50

    # Maximum size of one uploaded file
    max-file-size = "1.5G"

    # Whether to enable the upload cleanup job that periodically
    # removes invalid uploads
    cleanup-enable = true

    # The interval for the cleanup job
    cleanup-interval = 30 days

    # Age of invalid uploads to get collected by cleanup job
    cleanup-invalid-age = 7 days
  }

  web {
    # the host for binding the http server
    bind-host = "0.0.0.0"

    # the port for binding the http server
    bind-port = 9090

    # The name of the application rendered in the pages
    app-name = "Sharry"

    # The base url to use when constructing urls.
    baseurl = "http://localhost:9090/"
  }


  # authentication settings
  authc {
    # A secret used for signing the cookie. If it is empty a randomly
    # generated byte sequence is used. So it can be safely left
    # empty. It's only required if you want the cookies to survive
    # application restarts.
    #
    # It can be hex or base64 encoded, for example:
    #   hex:ffa2ff
    #   b64:ZNNJGE1xfehaLVsJXigp87v4y1JzNj0EMyUER5nmtTw=
    #
    # On Linux, random bits can be generated using /dev/urandom or
    # /dev/random:
    #   cat /dev/urandom | head -c 64 | base64 -w0
    app-key = ""

    # The lifetime of the authentication cookie that is used at the
    # client. The client can refresh the cookie by logging in with a
    # valid cookie.
    max-cookie-lifetime = 15 minutes

    # Authentication can be disabled here. Then every request is going
    # to be associated to the `default-user'.
    enable = true

    # the account name used when authentication is disabled
    default-user = "sharry"

    # it is possible to use external tools to validate login/password
    # pairs. A new account is created automatically for those
    # accounts.
    #
    # If multiple external strategies are enabled, they are tried in
    # some order and the first success wins.
    extern {
      # a preconifgured admin account to get started
      admin {
        enable = false
        login = admin
        password = admin
      }

      # use a system command and pass the login and password via
      # placeholder {login} and {password}.
      command {
        enable = false
        program = [
          "/path/to/someprogram"
          "{login}"
          "{password}"
        ]
        # the return code to consider successful verification
        success = 0
      }

      # use a http request to do password verification. It only checks
      # the response status code for a 200.
      http {
        enable = false
        # the url to use, it may contain placeholders {login} and {password}
        url = "https://somehost/auth?login={login}&pass={password}"
        # the http method to use
        method = "POST"
        # the body of the request. it may be empty (for GET requests),
        # placeholders {login} and {password} can be used here
        body = """{ "login": "{login}", "pass": "{password}" }"""
        # if `body' is non-empty, use this contentType
        content-type = "application/json"
      }
    }
  }
}